---
title: "Full Data Workflow"
author: S. Mason Garrison
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Full Data Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```


# Introduction

This vignette provides a start-to-finish tutorial for applying discordant-kinship regression with the {discord} package. It shows how to move from typical data structures to a pair-wise file, that we then analyze with discordant-kinship regression. The vignette covers three common data structures: wide format, long format, and pedigree data. It includes code for data cleaning, restructuring, and analysis. Examples use simulated data so the document knits immediately; you can later substitute your own variables or linked records.


What you'll do:
- See the three common starting formats for your data: wide, long, and pedigree.
- Convert your data into a wide format suitable for discordant-kinship regression.
- Adapt our analysis pipeline to your data, including ordering the dyads as well as creating the pair means and differences.


# Data Structures and Preparation

Your data may begin in wide, long, or pedigree form. Regardless of the starting point, the goal is to restructure the data into a wide format where each row represents a kinship pair, with variables for each member of the pair distinguished by suffixes (e.g., _1 and _2)

In this vignette, we will show how to prepare data starting from each of these formats. But first, let us load the necessary packages and data.

## Setup
```{r discord-setup, message = FALSE}
# For easy data manipulation
library(dplyr)
# For kinship linkages
library(NlsyLinks)
# For discordant-kinship regression
library(discord)
# To clean data frame names
library(janitor)
# tidy up output
library(broom)
# For pipe
library(magrittr)
# For pedigree data manipulation
library(BGmisc) 
# For pedigree plotting
library(ggpedigree)
library(ggplot2)
```


## Wide Format Data

The wide format data is the most straightforward to work with. Each row represents a kinship pair, and each variable appears twice—once for each member of the pair—using suffixes to distinguish individuals. Below is an example of how such a dataset might look:

```{r}
df_wide <- data.frame(
  pid = 1:5,
  id_s1 = c(101, 102, 103, 104, 105),
  id_s2 = c(201, 202, 203, 204, 205),
  age_s1 = c(30, 25, 40, 35, 28),
  age_s2 = c(28, 27, 38, 36, 30),
  height_s1 = c(175, 160, 180, 170, 165),
  height_s2 = c(170, 162, 178, 172, 168),
  weight_s1 = c(70, 60, 80, 75, 65),
  weight_s2 = c(68, 62, 78, 74, 66)
) 
df_wide  %>%
  knitr::kable()
```

Each row is a pair (pid), and columns ending _s1 and _s2 refer to the two members. If your outcome appears for both siblings (e.g., Y_s1, Y_s2) and your predictor appears for both siblings (e.g., X_s1, X_s2), you can proceed directly to the analysis section after conversion examples.


## Long Format Data Example

The long format data can be transformed into a wide format suitable for analysis. In this format, each row represents an individual, and there are columns for the kinship pair identifier and the individual's data. Below is an example of how such a dataset might look:

```{r}
# Ok, so I cheated by converting from our wide example above
# but you get the idea

df_long <- df_wide %>%
  tidyr::pivot_longer(
    cols = -pid,
    names_to = c(".value", "sibling"),
    names_sep = "_s"
  )
df_long %>%
  knitr::kable()
```

In this example, each individual is represented in a separate row, with a `pid` column to identify the kinship pair. If your data does not already have a unique identifier for each kinship pair, you may need to create one based on the available information. (More on how to do this below for pedigree data.)

The NLSY kinship links datasets, available in the {NlsyLinks} package, can be a valuable resource for this purpose, as they provide detailed kinship information for individuals in the NLSY79 and NLSY97 cohorts. This information can be used to restructure your data into a wide format suitable for discordant-kinship regression.

If you have data in this format, you can use the `pivot_wider()` function from the {tidyr} package to reshape it into a wide format. Here is an example of how to do this:

```{r}
df_long2wide <- df_long %>%
  tidyr::pivot_wider(
    names_from = sibling,
    values_from = c(id, age, height, weight),
    names_sep = "_s"
  )

df_long2wide %>%
  knitr::kable()
```


As you can see, each dyad is once again represented in a separate row, with columns for each member of the pair distinguished by suffixes (e.g., _s1 and _s2). You can now proceed to the analysis section.

## Pedigree Data Example

The pedigree data format is less common but can be transformed into a wide format suitable for analysis. As an added bonus, we can leverage the information provided by the pedigree to create a kinship linking file.

For those unfamilar, this format typically includes a unique identifier for each individual, their mother's identifier, and their father's identifier, along with other relevant variables. Our team has developed tools to facilitate this transformation, in a sister package, {BGmisc}, available on CRAN and GitHub. Below is an example of how such a dataset might look:

```{r echo=TRUE, fig.cap="Pedigree plot of the Potter dataset", fig.height=3, fig.width=4, message=FALSE, warning=FALSE}
data(potter)
ggpedigree(potter, config = list(
  label_method = "geom_text",
  label_nudge_y = .25
)) +
  labs(title = "Pedigree Plot of the Potter Dataset") +
  theme(legend.position = "bottom")
```


```{r}
data(potter)
df_ped <- potter %>%
  as.data.frame() %>%
  select(personID, sex, famID, momID, dadID, spouseID, 
         twinID, zygosity, first_name) %>% 
  mutate (x_var = round(rnorm(nrow(.), mean = 0, sd = 1), digits = 2))

df_ped %>% slice(1:5) %>%
  knitr::kable()
```

As you can see, each individual is represented in a separate row, with columns for their unique identifier, mother's identifier, father's identifier, and other relevant variables. To transform this data into a wide format suitable for discordant-kinship regression, we need to create kinship links based on the pedigree information. There are several steps involved in this process, and requires the use of specialized functions from the {BGmisc} package.


To extract the necessary kinship information, we need to compute two matrices: the additive genetic relatedness matrix and the shared environment matrix. Other matrices, such as mitochondrial, can also be computed if needed.

Using {BGmisc}, we compute:

- The additive genetic relatedness matrix (add).

- The shared environment matrix (cn), indicating whether kin were raised together (1) or apart (0).


```{r}
add <- ped2add(df_ped)
cn <- ped2cn(df_ped)
```

The `ped2add()` function computes the additive genetic relatedness matrix, which quantifies the genetic similarity between individuals based on their pedigree information. The `ped2cn()` function computes the shared environment matrix, which indicates whether individuals were raised in the same environment (1) or different environments (0).

The resulting matrices are symmetric, with diagonal elements representing self-relatedness (1.0). The off-diagonal elements represent the relatedness between pairs of individuals, with values ranging from 0 (no relatedness) to 0.5 (full siblings) to 1 (themselves).

We convert the component matrices into a wide-form dataframe of kin pairs using `com2links()`. Self-pairs and duplicate entries are removed.

```{r}
df_links <- com2links(
  writetodisk = FALSE,
  ad_ped_matrix = add,
  cn_ped_matrix = cn,
  drop_upper_triangular = TRUE
) %>%
  filter(ID1 != ID2)

df_links %>%
  slice(1:5) %>%
  knitr::kable()
```

As you can see, the `df_links` data frame contains pairs of individuals (ID1 and ID2) along with their additive genetic relatedness (`addRel`) and shared environment status (`cnuRel`). These data are in wide format, with each row representing a unique pair of individuals.

Further, we can tally the number of pairs by relatedness and shared environment to understand the composition of the dataset.

```{r}
df_links %>%
  group_by(addRel, cnuRel) %>%
  tally()  %>%
  knitr::kable()
```

This table shows the number of kinship pairs for each combination of genetic relatedness and shared environment status. Although the discord regression model can be used with any kin group, it is most interpretable when there is a single kinship group.



The package bundles these steps, including correct sibling ordering, via discord_data() and discord_regression

discord_data() reorders siblings so _1 has the higher outcome by default; you now have Y_mean, Y_diff, X_mean, X_diff ready to use.

```{r}
sessionInfo()
```
