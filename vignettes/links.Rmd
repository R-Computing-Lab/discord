---
title: "No Database? No Problem: Using discord with Simple Family Structures"
author: Mason Garrison
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Using discord with Simple Family Structures}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
options(rmarkdown.html_vignette.check_title = FALSE)
```


# Introduction

The {discord} package was originally developed for use with the National Longitudinal Survey of Youth (NLSY), but its functionality extends far beyond that. When paired with its sister package {BGmisc}, discord can be applied to any dataset containing basic family structure information, allowing researchers to explore genetic and environmental influences without requiring pre-constructed kinship links.


This vignette demonstrates how to:

- Construct kinship links from simple family data (e.g., individual ID, mother ID, father ID).
- Simulate phenotyipic data based on known genetic and environmental structures.
- Fit a discordant-kinship regression model using the simulated data.

We use tools from {BGmisc} and a toy dataset to illustrate the workflow.


# Loading Packages and Data

We begin by loading the required packages and a built-in dataset from {BGmisc}.


```{r echo=TRUE, message=FALSE, warning=FALSE}
library(BGmisc)
library(ggpedigree)
library(tidyverse)
library(discord)

data(potter)
```


We rename the family ID column to avoid naming conflicts and generate a pedigree-encoded data frame.

```{r}
df_potter <- potter

names(df_potter)[names(df_potter) == "famID"] <- "oldfam"

df_potter <- ped2fam(df_potter,
  famID = "famID",
  personID = "personID"
)
```


We also verify and repair sex coding to ensure compatibility with downstream pedigree operations.

```{r}
df_potter <- checkSex(df_potter,
  code_male = 1,
  code_female = 0,
  verbose = FALSE, repair = TRUE
)
```




```{r echo=TRUE, fig.cap="Pedigree plot of the Potter dataset", fig.height=3, fig.width=4, message=FALSE, warning=FALSE}
ggpedigree(potter, config = list(
  label_method = "geom_text",
  label_nudge_y = -.25
)) +
  labs(title = "Pedigree Plot of the Potter Dataset") +
  theme(legend.position = "bottom")
```

The pedigree plot provides a visual representation of the kinship structure in the dataset. Each node represents an individual, and the edges indicate familial relationships. 


# Constructing Kinship Links

To extract the necessary kinship information, we need to compute two matrices: the additive genetic relatedness matrix and the shared environment matrix. These matrices are derived from the pedigree data and are essential for understanding the genetic and environmental relationships among individuals.

Using {BGmisc}, we compute:

- The additive genetic relatedness matrix (add).

- The shared environment matrix (cn), indicating whether kin were raised together (1) or apart (0).


```{r}
add <- ped2add(df_potter)
cn <- ped2cn(df_potter)
```

The `ped2add()` function computes the additive genetic relatedness matrix, which quantifies the genetic similarity between individuals based on their pedigree information. The `ped2cn()` function computes the shared environment matrix, which indicates whether individuals were raised in the same environment (1) or different environments (0).

The resulting matrices are symmetric, with diagonal elements representing self-relatedness (1.0). The off-diagonal elements represent the relatedness between pairs of individuals, with values ranging from 0 (no relatedness) to 0.5 (full siblings) to 1 (themselves).

We convert the component matrices into a long-form data frame of kin pairs using `com2links()`. Self-pairs and duplicate entries are removed.


```{r}
df_links <- com2links(
  writetodisk = FALSE,
  ad_ped_matrix = add,
  cn_ped_matrix = cn,
  drop_upper_triangular = TRUE
) %>%
  filter(ID1 != ID2)

df_links %>%
  slice(1:10) %>%
  knitr::kable()
```

As you can see, the `df_links` data frame contains pairs of individuals (ID1 and ID2) along with their additive genetic relatedness (`addRel`) and shared environment status (`cnuRel`). These data are in wide format, with each row representing a unique pair of individuals.

Further, we can tally the number of pairs by relatedness and shared environment to understand the composition of the dataset.
```{r}
df_links %>%
  group_by(addRel, cnuRel) %>%
  tally()
```

As you can see, the dataset contains a variety of kinship pairs, including full siblings, parent-child, aunt-nephew, cousins, and unrelated individuals, with varying degrees of shared environment.

For this demonstration, we will focus on cousins. Cousins share some genetic relatedness but typically do not share the same environment. (In contrast, full siblings share both genetic relatedness and environment. Half-siblings share genetic relatedness but sometimes do not share the same environment, making them less ideal for this demonstration.)

We then extract two subsets:

- Full siblings: additive relatedness = 0.5 and shared environment = 1

- Cousins: additive relatedness = 0.125 and shared environment = 0

```{r}
df_siblings <- df_links %>%
  filter(addRel == .5) %>% # only full siblings %>%
  filter(cnuRel == 1) # only kin raised in the same home

df_cousin <- df_links %>%
  filter(addRel == .125) %>% # only cousins %>%
  filter(cnuRel == 0) # only kin raised in separate homes
```

Now for the rest of the vignette, we will use the cousin subset (`df_cousin`) to illustrate the process of simulating phenotypic data and fitting a discordant-kinship regression model.  However, given the small sample size of cousins in this dataset, we will simulate four datasets worth of cousins and combine them to increase the sample size.

```{r}
df_cousin <- rbind(
  df_cousin,
  df_cousin %>% mutate(ID1 = ID1 + 1000, ID2 = ID2 + 1000),
  df_cousin %>% mutate(ID1 = ID1 + 2000, ID2 = ID2 + 2000),
  df_cousin %>% mutate(ID1 = ID1 + 3000, ID2 = ID2 + 3000)
)
```

# Simulate Phenotypic Data

To simulate phenotypic data, we need to create a data frame that includes the kinship information and the outcome variables. We will simulate two outcome variables (y1 and y2) for each kin pair in the dataset. The `kinsim()` function from {discord} is used to generate the simulated data based on the specified variance structure. For convenience, we will generate data for all the cousins in `df_links`. However, we could also generate data for the full siblings or any other kinship pairs.

```{r}
set.seed(1234)
syn_df <- discord::kinsim(
  mu_all = c(2, 2),
  cov_a = .4,
  cov_e = .4,
  c_vector = df_cousin$cnuRel,
  r_vector = df_cousin$addRel
) %>%
  select(-c(
    A1_1, A1_2, A2_1, A2_2,
    C1_1, C1_2, C2_1, C2_2,
    E1_1, E1_2, E2_1, E2_2,
    r
  ))
```

The simulated data reflect a known variance structure: additive genetic covariance = .4, genetic relatedness of  0.125, no shared environment, and residual (unique environment) variance = 0.4. Latent component scores are dropped from the final dataset, but they can be useful for debugging and understanding the underlying structure of the data.

We bind the simulated outcome data to the links data to prepare it for modeling.

```{r}
data_demo <- cbind(df_cousin, syn_df)

data_demo %>% arrange(ID1, ID2)
summary(data_demo)

data_demo %>%
  slice(1:5) %>%
  knitr::kable()
```

The `data_demo` data frame now contains the kinship information along with the simulated outcome variables y1 and y2. Each row represents a pair of cousins, and the columns include the IDs of the individuals, their relatedness, and the simulated phenotypic data. 


# Fitting a Discordant-Kinship Regression Model

We then use `discord_regression()` to fit a discordant-kinship model, predicting y1 from y2. Based on the structure of the data, we expect that there will be a significant association between the two outcome variables, as there is a known overlapping non-shared environment covariance.

The model is fit using the `discord_regression()` function, which takes the following arguments:

```{r}
model_output <- discord_regression(
  data = data_demo,
  outcome = "y1",
  predictors = "y2",
  id = "id",
  sex = NULL,
  race = NULL,
  pair_identifiers = c("_1", "_2")
)
summary(model_output)
```

The output of the model includes estimates of the regression coefficients, standard errors, and p-values for the association between the two outcome variables.

# Alternative Specifications


If desired, one can manually prepare the data using `discord_data()` and then fit separate models for the individual-level, between-pair, and within-pair effects. This approach provides more flexibility in specifying the models and allows for a deeper understanding of the different components of the association.

```{r}
data_df <- discord_data(
  data = data_demo,
  outcome = "y1",
  predictors = "y2",
  id = "id",
  sex = NULL,
  race = NULL,
  demographics = "none",
  pair_identifiers = c("_1", "_2")
)
summary(data_df)



lm_ind <- lm(y1_1 ~ y2_1, data = data_df)
summary(lm_ind)

lm_ind2 <- lm(y1_2 ~ y2_2, data = data_df)

summary(lm_ind2)


lm_between <- lm(y1_mean ~ y2_mean, data = data_df)
summary(lm_between)

lm_within <- lm(y1_diff ~ y1_mean + y2_diff + y2_mean, data = data_df)
summary(lm_within)
```




# Conclusion

This vignette demonstrates how {BGmisc} and discord enable researchers to perform discordant-kinship analyses starting from simple family data. There’s no need for pre-constructed kinship links or specialized datasets like the NLSY—just basic family identifiers are sufficient to generate kinship structures and apply powerful behavior genetic models.



# References
